#!/usr/bin/perl
#
# macdir-ldap-update --- Update an LDAP directory
#
# Copyright 2023, CZ Software

use AppConfig qw(:argcount :expand);
use Carp;
use CZ::LDAPtools;
use Getopt::Long;
use Net::LDAPapi;
use Pod::Usage;
use strict;

my $CONF;
my $DEBUG_TIME = time();
my $LDAP;
my %VALID_ATTR = ();

my $opt_conf = '/etc/macdir/ldap.conf';
my $opt_debug;
my $opt_example;
my $opt_help;
my $opt_manual;

##############################################################################
# Subroutines
##############################################################################

# ------------------------------------------------
# output debugging information

sub dbg {
    if (!$opt_debug) {
        return;
    }
    my ($tmp)   = @_;
    my $now     = time();
    my $elapsed = $now - $DEBUG_TIME;
    print {*STDOUT} "$now ($elapsed) $tmp \n"
      or croak("debugging print to STDOUT failed: $!");
    $DEBUG_TIME = $now;
    return;
}

#-------------------------------------------------------------------------
# standard output

sub msg {
    my ($msg) = @_;
    print {*STDOUT} "$msg\n" or croak("print to STDOUT failed: $!");
    return;
}

# ------------------------------------------------------------------------
# Read configuration properties

sub read_conf {
    my ($filename) = @_;

    if (!$filename) {
        $filename = $opt_conf;
    }

    my $conf = AppConfig->new({});
    $conf->define(
        'ldap_bindtype',
        {
            DEFAULT  => 'gssapi',
            ARGCOUNT => ARGCOUNT_ONE
        }
    );
    $conf->define(
        'ldap_base',
        {
            DEFAULT  => 'dc=ca-zephyr,dc=org',
            ARGCOUNT => ARGCOUNT_ONE
        }
    );
    $conf->define(
        'ldap_host',
        {
            DEFAULT  => 'localhost',
            ARGCOUNT => ARGCOUNT_ONE
        }
    );
    $conf->define(
        'ldap_port',
        {
            DEFAULT  => '389',
            ARGCOUNT => ARGCOUNT_ONE
        }
    );
    $conf->define('ldap_password', { ARGCOUNT => ARGCOUNT_ONE });
    $conf->define('ldap_user',     { ARGCOUNT => ARGCOUNT_ONE });

    if (-e $filename) {
        $conf->file($filename) or die "ERROR: problem reading $filename";
    }

    if ($conf->ldap_host() =~ /,/xms) {
        my $one_host = lt_pool_host($conf->ldap_host);
        $conf->ldap_host($one_host);
    }

    return $conf;
}

#-------------------------------------------------------------------------
# Set valid attribute hash

sub set_valid_attr_list {

    my $note_oc = 'czPersonNote';
    my $base    = 'cn=schema,cn=config';
    my $filter  = 'cn={*}ca-zephyr';
    my @attrs   = ('olcObjectClasses');
    dbg("schema search - base:$base filter:$filter");
    my $msg = $LDAP->search_s(
        -basedn    => $base,
        -scope     => LDAP_SCOPE_SUBTREE,
        -filter    => $filter,
        -attrs     => \@attrs,
        -attrsonly => 0,
    );
    if ($opt_debug && $LDAP->errno != 0) {
        msg('errno: ' . $LDAP->errno . 'errstring:' . $LDAP->errstring);
        $LDAP->perror(
            "ERROR: problem searching using base:$base filter:$filter\n");
    }

    my %entries = %{ $LDAP->get_all_entries };

    for my $dn (keys %entries) {
        for my $oc (@{ $entries{$dn}{'olcObjectClasses'} }) {
            my $this_name;
            my $this_must_may;
            if ($oc =~ /\s+ name\s+(\S+)/xmsi) {
                $this_name = $1;
                $this_name =~ s/'//xmsg;
            }
            for my $type (('may', 'must')) {
                if ($oc =~ /\s+ ($type)\s+ \( ([\S\s\$]+?) \)/xmsi) {
                    my $mm = $2;
                    if ($this_must_may) {
                        $this_must_may .= '$' . $mm;
                    } else {
                        $this_must_may = $mm;
                    }
                }
            }
            if (!$this_name || !$this_must_may) {
                next;
            }
            if (lc($this_name) eq lc($note_oc)) {
                my @a_list = split /\$/, $this_must_may;
                for my $a (@a_list) {
                    $a =~ s/\s+//xmsg;
                    $VALID_ATTR{$a} = 1;
                }
                last;
            }
        }
    }

    if ($opt_debug) {
        for my $a (sort keys %VALID_ATTR) {
            dbg("VALID_ATTR = $a");
        }
    }

    return;
}

#-------------------------------------------------------------------------
# Find user dn given a user principal

sub find_user_dn {
    my ($id) = @_;

    if (!$id) {
        if ($ENV{'REMOTE_USER'}) {
            $id = $ENV{'REMOTE_USER'};
        } else {
            msg("ERROR: no user identifier specified");
            return;
        }
    }

    my $base;
    my $filter;
    my $scope;
    if ($id =~ /\@/xms) {
        $base   = $CONF->ldap_base;
        $scope  = LDAP_SCOPE_SUBTREE;
        $filter = "(&(objectClass=person)(krb5PrincipalName=$id))";
    } elsif ($id =~ /=/xms) {
        $base   = $id;
        $scope  = LDAP_SCOPE_BASE;
        $filter = '(objectClass=person)';
    } else {
        $base   = $CONF->ldap_base;
        $scope  = LDAP_SCOPE_SUBTREE;
        $filter = "(&(objectClass=person)(uid=$id))";
    }
    my @attrs       = ('objectClass');
    my $this_search = "base:$base filter:$filter scope:$scope";
    dbg($this_search);
    my $msg = $LDAP->search_s(
        -basedn    => $base,
        -scope     => $scope,
        -filter    => $filter,
        -attrs     => \@attrs,
        -attrsonly => 0,
    );
    if ($opt_debug && $LDAP->errno != 0) {
        msg('errno: ' . $LDAP->errno . 'errstring:' . $LDAP->errstring);
        $LDAP->perror("ERROR: problem searching using $this_search\n");
    }

    my %entries = %{ $LDAP->get_all_entries };

    if (scalar(keys %entries) > 1) {
        msg("ERROR: ambigious entry $this_search");
        return;
    }
    my $this_dn;
    for my $dn (keys %entries) {
        $this_dn = $dn;
    }
    dbg("user dn:$this_dn");
    return $this_dn;
}

#-------------------------------------------------------------------------
# Add a personal entry

sub add_pw {
    my ($cn, $av_ref) = @_;

    my $user_base = find_user_dn();
    if (!$user_base) {
        exit 1;
    }
    my $dn      = "cn=$cn,$user_base";
    my @av_list = @{$av_ref};

    my %ldap_av = (
        'objectClass' => ['top', 'czPersonNote'],
        'cn'          => [$cn],
    );
    my $err = '';
    for my $av (@av_list) {
        if ($av =~ /(\S+)=(.*)/xms) {
            my $a = $1;
            my $v = $2;
            if (!$VALID_ATTR{$a}) {
                $err .= "ERROR: invalid attribute $a\n";
                next;
            }
            push @{ $ldap_av{$a} }, $v;
        } else {
            $err .= "ERROR: invalid attrbute=value expression\n";
            next;
        }
    }

    msg("Adding entry: $cn");
    my $status = $LDAP->add_s($dn, \%ldap_av);

    if ($status != 0) {
        msg("status: $status");
        msg('errno:' . $LDAP->errno . ' errstring:' . $LDAP->errstring);
        $LDAP->perror("ERROR: problem adding $dn\n");
        exit 1;
    }
    return;
}

# --------------------------------------------------------------------
# Update a password entry

sub update_pw {
    my ($cn, $vals_ref) = @_;
    my @vals = @{$vals_ref};

    my $user_base = find_user_dn();
    if (!$user_base) {
        exit 1;
    }
    msg("Updating $cn\n");

    return;
}

# --------------------------------------------------------------------
# Delete an A record

sub delete_pw {
    my ($cn) = @_;
    my $user_base = find_user_dn();
    if (!$user_base) {
        exit 1;
    }

    my $dn = "cn=$cn,$user_base";

    msg("Deleting $dn\n");
    my $status = $LDAP->delete_s($dn);
    if ($status != 0) {
        msg("status: $status\n");
        msg('errno:' . $LDAP->errno . ' errstring:' . $LDAP->errstring);
        $LDAP->perror("ERROR: problem deleting $dn\n");
        exit 1;
    }

    return;
}

##############################################################################
# Main routine
##############################################################################

# -- get options
GetOptions(
    'conf=s'  => \$opt_conf,
    'debug'   => \$opt_debug,
    'example' => \$opt_example,
    'help'    => \$opt_help,
    'manual'  => \$opt_manual
);

# -- Flush output immediately
local $| = 1;

# Display an example configuration file
if ($opt_example) {
    example_conf();
    exit;
}

if ($ARGV[0] eq 'help') {
    $opt_help = 1;
}
if ($ARGV[0] eq 'manual') {
    $opt_manual = 1;
}

# Display help if requested
if ($opt_help) {
    pod2usage(-verbose => 0);
}
if ($opt_manual) {
    pod2usage(-verbose => 2);
}

# Read the configuration file
dbg("Configuration file: $opt_conf");
$CONF = read_conf($opt_conf);

if ($CONF->ldap_bindtype eq 'simple') {
    $LDAP = lt_ldap_connect(
        {
            host     => $CONF->ldap_host,
            port     => $CONF->ldap_port,
            bindtype => $CONF->ldap_bindtype,
            user_dn  => $CONF->ldap_user,
            user_pw  => $CONF->ldap_password,
            debug    => $opt_debug
        }
    );
} else {
    $LDAP = lt_ldap_connect(
        {
            host     => $CONF->ldap_host,
            port     => $CONF->ldap_port,
            bindtype => $CONF->ldap_bindtype,
            debug    => $opt_debug
        }
    );
}

set_valid_attr_list();

my $action = shift(@ARGV);
if (!$action) {
    msg('ERROR: Missing action');
    exit 1;
}

dbg("action: $action");
if ($action =~ /^add$/xmsi) {
    my $cn   = shift(@ARGV);
    my @vals = @ARGV;
    add_pw($cn, \@vals);
} elsif ($action =~ /^update$/xmsi) {
    my $cn      = shift(@ARGV);
    my @updates = @ARGV;
    update_pw($cn, \@updates);
} elsif ($action =~ /^delete$/xmsi) {
    my $cn = shift(@ARGV);
    delete_pw($cn);
} else {
    msg("ERROR: action '$action' unknown");
    exit 1;
}

$LDAP->unbind;

exit;

__END__

=head1 NAME

cz-pdns-ldap - Update PowerDNS entries in LDAP

=head1 SYNOPSIS

    cz-pdns-ldap find [<name fragment>] [<options>]
    cz-pdns-ldap show <hostname> [<options>]

    cz-pdns-ldap add <type> <id> [<attributes>] [<options>]
    cz-pdns-ldap update <hostname> [<attributes>] [<options>]
    cz-pdns-ldap delete <type> <hostname>|<ip> [--debug]

    cz-pdns-ldap create <hostname> <ip> [<attributes>] [<options>]
    cz-pdns-ldap purge <hostname> [--debug]

=head1 DESCRIPTION

Update Power DNS entries in an LDAP directory.

=head1 ACTIONS

=over 4

=item add <type> <hostname> <ip address>

Add directory entries for A, PTR, CNAME DNS records or add an LDAP
mapping entry for Kerberos principals.

=item create <hostname> <ip>

Create both A and PTR records and a Kerberos LDAP mapping entry.

=item delete <type> <hostname>

Delete an A, PTR, CNAME, and Kerberos LDAP entries.

=item find <hostname fragment>

=item purge <hostname>

Delete A, PTR, and Kerberos entries in the directory.

=item show <hostname>

=item update <hostname>

=back

=head1 OPTIONS

=over 4

=item --example

Print an example configuration file to STDOUT.

=item --help

Display short help text.

=item --manual

Display the complete documentation.

=item --debug

Display debugging messages.

=back

=head1 EXAMPLES

=head2 Add SRV entry

    cz-pdns-ldap add srv afs-prserver udp 86400 \
        2 10 7003 afs1.cz.org \
        2 20 7003 afs2.cz.org \
        2 10 7003 afs3.cz.org

=head1 AUTHOR

Bill MacAllister <bill@ca-zephyr.org>

=head1 COPYRIGHT

Copyright (C) 2023, CZ Software

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

=cut
